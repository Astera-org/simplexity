# 5.1. Adding New Generative Processes

The Simplexity framework is designed to be extensible, allowing you to add new custom generative processes (data sources) for your experiments. This typically involves defining the process logic (often by specifying its transition matrices if it's an HMM/GHMM variant) and making it accessible through the configuration system.

Here's a step-by-step guide:

## 1. Understand the `GenerativeProcess` Interface

Recall that all generative processes must conform to the `simplexity.generative_processes.generative_process.GenerativeProcess` abstract base class. If your new process is significantly different from an HMM/GHMM, you might need to implement this interface directly. However, for many sequence generation tasks, defining a new type of HMM or GHMM is common.

## 2. Define Transition Matrix Function (for HMM/GHMM variants)

If your new process can be described by transition matrices for an HMM or GHMM:

*   **Open `simplexity/generative_processes/transition_matrices.py`:**
    This file contains dictionaries like `HMM_MATRIX_FUNCTIONS` and `GHMM_MATRIX_FUNCTIONS`. These map a `process_name` (string) to a function that returns the JAX array(s) representing the transition matrices.

*   **Create a new function:** Write a Python function that takes any necessary parameters (e.g., `p`, `alpha`, number of states) and returns the transition matrix (or matrices) for your new process. The shape and interpretation of these matrices must be compatible with `HiddenMarkovModel` or `GeneralizedHiddenMarkovModel` respectively.
    *   **HMM Example:** For an HMM, the transition matrix typically has shape `(vocab_size, num_hidden_states, num_hidden_states)`.
    *   **GHMM Example:** For a GHMM, it might be more complex, e.g., a list of matrices or a higher-order tensor.

    ```python
    # In simplexity/generative_processes/transition_matrices.py

    def my_custom_process_matrices(param1: float, num_states: int) -> jax.Array:
        # ... logic to construct your HMM transition matrix ...
        # Example: vocab_size = 2
        # matrix = jnp.array([...]) # Shape: (2, num_states, num_states)
        # return matrix
        pass # Replace with actual implementation

    # Add to the appropriate dictionary:
    HMM_MATRIX_FUNCTIONS["my_custom_process"] = my_custom_process_matrices
    # or GHMM_MATRIX_FUNCTIONS if it's a GHMM
    ```

## 3. Create a Configuration YAML File

Create a new YAML file in the `simplexity/configs/generative_process/` directory. The filename (without `.yaml`) will be the name you use in your main experiment configuration.

*   **File:** `simplexity/configs/generative_process/my_custom_process.yaml`

*   **Content:**
    ```yaml
    _target_: simplexity.generative_processes.builder.build_hidden_markov_model # Or build_generalized_hidden_markov_model
    process_name: "my_custom_process"  # Must match the key in HMM_MATRIX_FUNCTIONS

    # Parameters for your matrix function (my_custom_process_matrices)
    param1: 0.75
    num_states: 4

    # Common GenerativeProcess config (from simplexity.configs.generative_process.config.Config)
    name: "my_custom_process" # Should match the filename for clarity
    vocab_size: 2 # Specify the vocabulary size of your process
    # instance: will be populated by the _target_ call with above params
    ```
    *   `_target_`: Points to the appropriate builder function in `simplexity.generative_processes.builder.py`.
    *   `process_name`: The unique string key you used in `HMM_MATRIX_FUNCTIONS` or `GHMM_MATRIX_FUNCTIONS`.
    *   Other keys (`param1`, `num_states` in this example) are the arguments to your `my_custom_process_matrices` function. Hydra will pass these from the YAML file to the function.
    *   `name`: The overall name for this configuration group item.
    *   `vocab_size`: The vocabulary size of your process. This is important for the rest of the framework to understand the data.

## 4. (Optional) Define a Custom Dataclass for Configuration

If your new process has many specific configuration parameters, you might want to define a dedicated dataclass for its configuration in `simplexity/configs/generative_process/config.py` for better type safety and clarity, similar to `EvenOnesConfig` or `FanizzaConfig`.

```python
# In simplexity/configs/generative_process/config.py

@dataclass
class MyCustomProcessConfig(ProcessInstanceConfig):
    # _target_: build_hidden_markov_model # This is often inherited or set by convention
    # process_name: "my_custom_process"
    param1: float
    num_states: int
```
Then, your `my_custom_process.yaml` would have its `_target_` pointing to this dataclass if you were instantiating it directly, but typically the main `Config` for `generative_process` (`simplexity.configs.generative_process.config.Config`) has an `instance: ProcessInstanceConfig` field, and your YAML populates the sub-fields that the chosen `_target_` (e.g., `build_hidden_markov_model`) will use.

The current setup primarily relies on the builder functions consuming `process_name` and `**kwargs` directly from the YAML without needing a specific dataclass per process type, as long as the parameters match the signature of the matrix function.

## 5. Implement a Custom `GenerativeProcess` Subclass (Advanced)

If your process is not an HMM/GHMM or requires very custom logic for `emit_observation`, `transition_states`, or `generate`:

1.  **Create a new Python file:** E.g., `simplexity/generative_processes/my_custom_generator.py`.
2.  **Define your class:**
    ```python
    import equinox as eqx
    from simplexity.generative_processes.generative_process import GenerativeProcess, State
    # ... other imports ...

    class MyCustomGenerator(GenerativeProcess[MyStateType]): # Define MyStateType
        # ... your parameters ...

        def __init__(self, ..., key: jax.PRNGKey):
            # ... initialization ...
            pass

        @property
        def vocab_size(self) -> int:
            # ... return vocab size ...
            pass

        @property
        def initial_state(self) -> MyStateType:
            # ... return initial state ...
            pass

        def emit_observation(self, state: MyStateType, key: chex.PRNGKey) -> chex.Array:
            # ... your logic ...
            pass

        def transition_states(self, state: MyStateType, obs: chex.Array) -> MyStateType:
            # ... your logic ...
            pass

        # You might also override generate() if jax.lax.scan with emit/transition is not suitable
        # Override other methods like observation_probability_distribution as needed
    ```
3.  **Create a builder function (Optional but Recommended for Hydra):**
    In `simplexity/generative_processes/builder.py` (or a new builder file if preferred):
    ```python
    def build_my_custom_generator(vocab_size: int, param_a: str, seed: int) -> MyCustomGenerator:
        key = jax.random.PRNGKey(seed)
        return MyCustomGenerator(vocab_size, param_a, key=key)
    ```
4.  **Create a configuration YAML:**
    In `simplexity/configs/generative_process/my_custom_generator.yaml`:
    ```yaml
    _target_: simplexity.generative_processes.builder.build_my_custom_generator # Or directly to MyCustomGenerator if no builder
    vocab_size: 10
    param_a: "some_value"
    seed: 42
    name: "my_custom_generator"
    # instance field will be populated
    ```

## 6. Update Configuration Schemas (If Necessary)

If you introduced new top-level configuration structures (e.g., a new dataclass for your process in `simplexity.configs.generative_process.config.py` that needs to be selectable), ensure the main `Config` objects or relevant `Union` types in `simplexity.configs.*` are updated to recognize your new type if you want strict type checking via Hydra.
However, the current builder pattern mostly relies on `process_name` and `kwargs`, which is quite flexible.

## 7. Use Your New Generative Process

In your main experiment YAML (e.g., `experiment.yaml`), change the `generative_process` default:

```yaml
defaults:
  # ...
  - generative_process@training_data_generator: my_custom_process # Or my_custom_generator
  - generative_process@validation_data_generator: my_custom_process # Or my_custom_generator
  # ...
```

Now, when you run an experiment, Hydra will use your new generative process configuration to instantiate and use your custom data source. 