import chex
import equinox as eqx
import jax
import jax.numpy as jnp
import numpy as np

from simplexity.generative_processes.generative_process import GenerativeProcess


def get_probable_sequences(
        process: GenerativeProcess, sequence_len: int, min_prob: float = 1e-13
    ) -> tuple[jax.Array, jax.Array]:
    """Get a set of sequences that are likely to be generated by the process."""
    # TODO: implement
    num_sequences = 1
    return jnp.zeros((num_sequences, sequence_len)), jnp.zeros(num_sequences)

def markov_approximation(process: GenerativeProcess, sequence_len: int, min_prob: float = 1e-13) -> jax.Array:
    """Approximate the process as a Markov chain."""
    # TODO: implement
    sequences, probabilities = get_probable_sequences(process, sequence_len, min_prob)
    num_observations = len(set(sequences.flatten()))
    num_states = sequences.shape[0]
    return jnp.zeros((num_observations, num_states, num_states))


def log_matmul(A: jax.Array, B: jax.Array) -> jax.Array:
    """Compute the log of the matrix product of A and B.

    A and B are log-space matrices.
    """
    sum_mat = A[:, :, None] + B[None, :, :]
    return jax.nn.logsumexp(sum_mat, axis=1)

@eqx.filter_jit
def normalize_simplex(simplex: jax.Array) -> jax.Array:
    """Normalize probabilities to sum to 1."""
    chex.assert_rank(simplex, 1)
    return simplex / jnp.sum(simplex)

def stationary_distribution(transition_matrix: jax.Array) -> jax.Array:
    """Compute the stationary eigenvector of a transition matrix.
    
    the jax.numpy version of linalg.eig is buggy, so we use numpy instead.
    """
    eigenvalues, eigenvectors = np.linalg.eig(np.array(transition_matrix))
    eigenvectors = jnp.array(eigenvectors)
    stationary_eigenvector = eigenvectors[:, np.isclose(eigenvalues, 1)].squeeze().real
    return normalize_simplex(stationary_eigenvector)
