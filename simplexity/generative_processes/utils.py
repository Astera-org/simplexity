import chex
import equinox as eqx
import jax
import jax.numpy as jnp
import numpy as np

from simplexity.generative_processes.generative_process import GenerativeProcess


def get_probable_sequences(
    process: GenerativeProcess, sequence_len: int, min_prob: float = 1e-13
) -> tuple[jax.Array, jax.Array]:
    """Get a set of sequences that are likely to be generated by the process."""
    # TODO: implement
    num_sequences = 1
    return jnp.zeros((num_sequences, sequence_len)), jnp.zeros(num_sequences)


def markov_approximation(process: GenerativeProcess, sequence_len: int, min_prob: float = 1e-13) -> jax.Array:
    """Approximate the process as a Markov chain."""
    # TODO: implement
    sequences, probabilities = get_probable_sequences(process, sequence_len, min_prob)
    num_observations = len(set(sequences.flatten()))
    num_states = sequences.shape[0]
    return jnp.zeros((num_observations, num_states, num_states))


@eqx.filter_jit
def normalize_simplex(simplex: jax.Array) -> jax.Array:
    """Normalize probabilities to sum to 1."""
    chex.assert_rank(simplex, 1)
    return simplex / jnp.sum(simplex)


def stationary_distribution(transition_matrix: jax.Array) -> jax.Array:
    """Compute the stationary eigenvector of a transition matrix.

    the jax.numpy version of linalg.eig is buggy, so we use numpy instead.
    """
    eigenvalues, eigenvectors = np.linalg.eig(np.array(transition_matrix))
    eigenvectors = jnp.array(eigenvectors)
    stationary_eigenvector = eigenvectors[:, np.isclose(eigenvalues, 1)].squeeze().real
    return normalize_simplex(stationary_eigenvector)


def assert_proportional(a: jax.Array, b: jax.Array, rtol: float = 1e-6, atol: float = 0):
    """Assert that two arrays are proportional."""

    def normalize(x: jax.Array) -> jax.Array:
        return x / jnp.maximum(jnp.abs(x).max(), 1e-6)

    chex.assert_equal_shape([a, b])
    norm_a = normalize(a)
    norm_b = normalize(b)
    try:
        chex.assert_trees_all_close(norm_a, norm_b, rtol=rtol, atol=atol)
    except AssertionError as e1:
        try:
            chex.assert_trees_all_close(norm_a, -norm_b, rtol=rtol, atol=atol)
        except AssertionError as e2:
            if jnp.sum(jnp.abs(norm_b - norm_a)) > jnp.sum(jnp.abs(norm_b + norm_a)):
                e = e2
            else:
                e = e1
            raise AssertionError(f"Arrays are not proportional: {a} and {b}.\n{e}") from e
